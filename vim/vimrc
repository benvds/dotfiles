" Specify a directory for plugins (for Neovim: ~/.local/share/nvim/plugged)
call plug#begin('~/.vim/plugged')

" Make sure you use single quotes

Plug 'Shougo/vimproc.vim', { 'do': 'make' }
Plug 'ctrlpvim/ctrlp.vim'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-surround'
" Plug 'machakann/vim-sandwich'
Plug 'tpope/vim-ragtag'
Plug 'tpope/vim-fugitive'
Plug 'othree/yajs.vim', { 'for': 'javascript' }
Plug 'editorconfig/editorconfig-vim'
Plug 'altercation/vim-colors-solarized'
Plug 'mileszs/ack.vim'
" Plug 'Shougo/neocomplcache'
" Plug 'Shougo/neosnippet'
Plug 'Valloric/YouCompleteMe'
Plug 'ervandew/supertab'
Plug 'SirVer/ultisnips'
Plug 'honza/vim-snippets'
Plug 'tomtom/tcomment_vim'
" Plug 'airblade/vim-gitgutter' " makes vim slow
Plug 'mbbill/undotree'
Plug 'mattn/emmet-vim', { 'for': 'html' }
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-eunuch'
Plug 'vim-ruby/vim-ruby'
Plug 'tpope/vim-endwise'
" Plug 'tpope/vim-rails' " makes vim slow
Plug 'itchyny/lightline.vim'
Plug 'w0rp/ale'
Plug 'ntpeters/vim-better-whitespace'


" Writing
Plug 'tpope/vim-markdown', { 'for': 'markdown' }

Plug 'elixir-lang/vim-elixir', { 'for': 'elixir' }
Plug 'kchmck/vim-coffee-script', { 'for': 'coffee' }
Plug 'slim-template/vim-slim', { 'for': 'slim' }
Plug 'cakebaker/scss-syntax.vim', { 'for': 'scss' }
Plug 'leafgarland/typescript-vim', { 'for': 'typescript' }
Plug 'elmcast/elm-vim', { 'for': 'elm' }

" Initialize plugin system
call plug#end()

let g:netrw_banner = 0

" set rtp+=/usr/local/bin/fzf
" set rtp+=~/.fzf

set guioptions+=e
let g:fzf_layout = { 'down': '~20%' }
nnoremap <silent> <C-b> :Files<CR>

" EditorConfig
" use the system editor config, makes startup faster
let g:EditorConfig_core_mode = 'external_command'

" Ctrl-P

" nnoremap <silent> <C-b> :CtrlPMRU<CR>
let g:ctrlp_reuse_window = 'netrw\|help\|quickfix\|vimfiler'
let g:ctrlp_custom_ignore = {
    \ 'dir':  '\.git$\|\.hg$\|\.svn$',
    \ 'file': '\.exe$\|\.so$\|\.dll$' }

let g:ctrlp_user_command = {
    \ 'types': {
        \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
        \ 2: ['.hg', 'hg --cwd %s locate -I .'],
    \ },
    \ 'fallback': 'find %s -type f'
\ }

if executable('rg')
  let g:ctrlp_user_command = 'rg --files %s'
  let g:ctrlp_use_caching = 0
  let g:ctrlp_working_path_mode = 'ra'
  let g:ctrlp_switch_buffer = 'et'
endif

" make YCM compatible with UltiSnips (using supertab)
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
let g:SuperTabDefaultCompletionType = '<C-n>'

" better key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

 " neocomplcache

" let g:acp_enableAtStartup = 0
" let g:neocomplcache_enable_at_startup = 1
" let g:neocomplcache_enable_camel_case_completion = 1
" let g:neocomplcache_enable_smart_case = 1
" let g:neocomplcache_enable_underbar_completion = 1
" let g:neocomplcache_enable_auto_delimiter = 1
" let g:neocomplcache_max_list = 15
" let g:neocomplcache_force_overwrite_completefunc = 1
"
" " SuperTab like snippets behavior.
" imap <silent><expr><TAB> neosnippet#expandable() ?
"             \ "\<Plug>(neosnippet_expand_or_jump)" : (pumvisible() ?
"             \ "\<C-e>" : "\<TAB>")
" smap <TAB> <Right><Plug>(neosnippet_jump_or_expand)
"
" " Define dictionary.
" let g:neocomplcache_dictionary_filetype_lists = {
"             \ 'default' : '',
"             \ 'vimshell' : $HOME.'/.vimshell_hist',
"             \ 'scheme' : $HOME.'/.gosh_completions'
"             \ }
"
" " Define keyword.
" if !exists('g:neocomplcache_keyword_patterns')
"     let g:neocomplcache_keyword_patterns = {}
" endif
" let g:neocomplcache_keyword_patterns._ = '\h\w*'
"
" if !(exists('g:neocomplcache_same_filetype_lists'))
"    let g:neocomplcache_same_filetype_lists = {}
" endif
" let g:neocomplcache_same_filetype_lists.erb = 'html,eruby,ruby'
" let g:neocomplcache_same_filetype_lists.eruby = 'html,erb,ruby'
"
" " Plugin key-mappings.
"
" " These two lines conflict with the default digraph mapping of <C-K>
" " If you prefer that functionality, add
" imap <C-k> <Plug>(neosnippet_expand_or_jump)
" smap <C-k> <Plug>(neosnippet_expand_or_jump)
"
" inoremap <expr><C-g> neocomplcache#undo_completion()
" inoremap <expr><C-l> neocomplcache#complete_common_string()
" inoremap <expr><CR> neocomplcache#complete_common_string()
"
" inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
" inoremap <expr><C-y> neocomplcache#close_popup()
"
" " Enable omni completion.
" autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
" autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
" autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
" autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
" autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
" autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete ts=2 sw=2
"
" " Enable heavy omni completion.
" if !exists('g:neocomplcache_omni_patterns')
"     let g:neocomplcache_omni_patterns = {}
" endif
"
" let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
" let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
" let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
" let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
" let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
"
" " Use honza's snippets.
" let g:neosnippet#snippets_directory='~/.vim/plugged/vim-snippets/snippets'
"
" " Enable neosnippet snipmate compatibility mode
" let g:neosnippet#enable_snipmate_compatibility = 1
"
" " https://github.com/spf13/spf13-vim/issues/539
" let g:neosnippet#disable_runtime_snippets = { "_": 1, }
"
" " For snippet_complete marker.
" if has('conceal')
"     set conceallevel=2 concealcursor=i
" endif
"
" " Disable the neosnippet preview candidate window
" " When enabled, there can be too much visual noise
" " especially when splits are used.
" set completeopt-=preview
"
"
" " Disable AutoComplPop.
" let g:acp_enableAtStartup = 0
" " Use neocomplcache.
" let g:neocomplcache_enable_at_startup = 1
" " Use smartcase.
" let g:neocomplcache_enable_smart_case = 1
" " Set minimum syntax keyword length.
" let g:neocomplcache_min_syntax_length = 3
" " Plugin key-mappings.
" inoremap <expr><C-g>     neocomplcache#undo_completion()
" inoremap <expr><C-l>     neocomplcache#complete_common_string()
"
" " Recommended key-mappings.
" " <CR>: close popup and save indent.
" inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
" function! s:my_cr_function()
"   return neocomplcache#smart_close_popup() . "\<CR>"
"   " For no inserting <CR> key.
"   "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
" endfunction
" " <TAB>: completion.
" inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" " <C-h>, <BS>: close popup and delete backword char.
" inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
" inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
" inoremap <expr><C-y>  neocomplcache#close_popup()
" inoremap <expr><C-e>  neocomplcache#cancel_popup()

" use ag instead of ack
if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif
" use ripgrep instead of ag
if executable('rg')
  let g:ackprg = 'rg --vimgrep --no-heading'
endif

" Undotree
nnoremap <F5> :UndotreeToggle<cr>

" Lightline
set laststatus=2
let g:lightline = {
      \ 'colorscheme': 'solarized',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'linter_warnings', 'linter_errors', 'linter_ok' ],
      \             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ]
      \ },
      \ 'component_function': {
      \   'gitbranch': 'fugitive#head'
      \ },
      \ 'component_expand': {
      \   'linter_warnings': 'LightlineLinterWarnings',
      \   'linter_errors': 'LightlineLinterErrors',
      \   'linter_ok': 'LightlineLinterOK'
      \ },
      \ 'component_type': {
      \   'linter_warnings': 'warning',
      \   'linter_errors': 'error',
      \   'linter_ok': 'ok'
      \ },
      \ }

" Write this in your vimrc file
let g:ale_lint_on_text_changed = 'never'
" You can disable this option too
" if you don't want linters to run on opening a file
let g:ale_lint_on_enter = 0

let g:ale_fixers = {
\   'javascript': ['prettier'],
\}
let g:ale_javascript_prettier_use_local_config = 1

autocmd User ALELint call lightline#update()

" ale + lightline
function! LightlineLinterWarnings() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d --', all_non_errors)
endfunction

function! LightlineLinterErrors() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d >>', all_errors)
endfunction

function! LightlineLinterOK() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? 'âœ“' : ''
endfunction

" General

let mapleader="\<Space>"

syntax on                       " Turn on syntax highlighting

set number                      " Line numbers are good
set ruler                       " Show current position in statusline
set showmode                    " Show current mode down the bottom
set visualbell                  " No sounds

set ignorecase                  " Ignore case when searching

set conceallevel=0

" press esc to stop search highlight
set hlsearch
nnoremap <silent> <esc> :noh<return><esc>

set noswapfile
set nobackup
set nowb

set autoindent
set smartindent
set smartcase
set shiftwidth=4
set softtabstop=4
set tabstop=4
set expandtab
set colorcolumn=80
set autoread
set scrolloff=5
set updatetime=250

" make vim in terminal somewhat faster
set ttyfast
set lazyredraw

"key mapping for window navigation
map <C-h> <C-w>h
" map <C-j> <C-w>j
" map <C-k> <C-w>k
map <C-l> <C-w>l

"key mapping for tab navigation
nnoremap <C-k> :tabprevious<CR>
nnoremap <C-j> :tabnext<CR>

" retain visual selection after indent
vnoremap > >gv
vnoremap < <gv

" Quickly edit/reload the vimrc file
nmap <silent> <leader>ev :e $MYVIMRC<CR>
nmap <silent> <leader>sv :so $MYVIMRC<CR>

nnoremap <leader>. <c-^>        " Switch between last buffer

colorscheme solarized
set bg=dark

if has("gui_running")
    let g:solarized_contrast="high"
    let g:solarized_visibility="high"
    set cursorline                  " Highlight the screenline of the cursor
    set linespace=6
    set guifont=Hack:h11
endif

" try to speed up ruby
let g:ruby_path="/usr/bin/ruby"

" somehow this only works when set globally
set re=1
let ruby_no_expensive=1
set noballooneval
let g:netrw_nobeval = 1

augroup ft_rb
    au!
    " fix the SLOOOW syntax highlighting
    au FileType ruby setlocal re=1 foldmethod=manual
augroup END

" http://vim.wikia.com/wiki/Search_for_visually_selected_text
" Search for selected text, forwards or backwards.
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
